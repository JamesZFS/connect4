/*********************************************************	Strategy.h : 策略接口文件                           **	张永锋                                              **	zhangyf07@gmail.com                                 **	2014.5                                              **********************************************************/#ifndef STRATEGY_H_#define STRATEGY_H_#include "libs.h"#include "Point.h"#include "Node.h"#include "Status.h"#include "Judge.h"extern "C" Point *getPoint(const int M, const int N, const int *top, const int *_board,						   const int lastX, const int lastY, const int noX, const int noY);extern "C" void clearPoint(Point *p);void clearArray(int M, int N, int **board);/*	添加你自己的辅助函数*/Status root_status;Status cur_status;Point uctSearch();    // s0 - root_statusNode *treePolicy(Node *v);Node *expand(Node *v);Node *bestChild(Node *v, double c);int randPolicy();    // Default Policy, return delta - gain, without modifying root_statusvoid updateAbove(Node *v, int delta);    // backup from vbool atTerminal(const Point &action);    // whether at terminal nodeinline int winner(const Point &action, int player)	// 0 - tie{	return player == 1		   ? (userWin(action.x, action.y, Node::M, Node::N, cur_status.board) ? 1 : 0)		   : (machineWin(action.x, action.y, Node::M, Node::N, cur_status.board) ? 2 : 0);}inline void makeMove(const Point &action, int player)        // modify cur_state{	cur_status.board[action.x][action.y] = player;    // make move	--cur_status.top[action.y];}inline void resetStatus(){	cur_status.copyFrom(root_status, Node::M, Node::N);    // reset current board}inline size_t randint(size_t x){	return rand() % x;}inline void switchPlayer(int &player){	player = (player == 1 ? 2 : 1);}#endif